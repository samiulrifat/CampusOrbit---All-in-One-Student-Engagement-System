{"ast":null,"code":"const express = require('express');\nconst router = express.Router();\nconst bcrypt = require('bcrypt');\nconst jwt = require('jsonwebtoken');\nconst User = require('../models/User');\nconst {\n  verifyToken\n} = require('../middleware/auth'); // Import your JWT verify middleware\nconst JWT_SECRET = process.env.JWT_SECRET || \"your_secret_key_here\";\n// REGISTER route\nrouter.post('/register', async (req, res) => {\n  try {\n    const {\n      name,\n      email,\n      password,\n      role\n    } = req.body;\n    if (!name || !email || !password) {\n      return res.status(400).json({\n        error: 'Name, email, and password are required'\n      });\n    }\n    const existingUser = await User.findOne({\n      email\n    });\n    if (existingUser) {\n      return res.status(400).json({\n        error: 'Email is already registered'\n      });\n    }\n    const saltRounds = 10;\n    const hashedPassword = await bcrypt.hash(password, saltRounds);\n    const user = new User({\n      name,\n      email,\n      passwordHash: hashedPassword,\n      role: role || 'student'\n    });\n    await user.save();\n    const token = jwt.sign({\n      userId: user._id,\n      role: user.role\n    }, JWT_SECRET, {\n      expiresIn: '1d'\n    });\n    res.status(201).json({\n      message: 'User registered successfully',\n      token\n    });\n  } catch (err) {\n    console.error('Register error:', err);\n    res.status(500).json({\n      error: 'Server error'\n    });\n  }\n});\n// LOGIN route\nrouter.post('/login', async (req, res) => {\n  try {\n    const {\n      email,\n      password\n    } = req.body;\n    if (!email || !password) {\n      return res.status(400).json({\n        error: 'Email and password are required'\n      });\n    }\n    const user = await User.findOne({\n      email\n    });\n    if (!user) {\n      return res.status(401).json({\n        error: 'Invalid email or password'\n      });\n    }\n    const isValid = await bcrypt.compare(password, user.passwordHash);\n    if (!isValid) {\n      return res.status(401).json({\n        error: 'Invalid email or password'\n      });\n    }\n    const token = jwt.sign({\n      userId: user._id,\n      role: user.role\n    }, JWT_SECRET, {\n      expiresIn: '1d'\n    });\n    res.json({\n      message: 'Login successful',\n      token\n    });\n  } catch (err) {\n    console.error('Login error:', err);\n    res.status(500).json({\n      error: 'Server error'\n    });\n  }\n});\n// GET current authenticated user info\nrouter.get('/me', verifyToken, async (req, res) => {\n  try {\n    const userId = req.user.userId; // obtained from verifyToken middleware\n    const user = await User.findById(userId).select('-passwordHash'); // exclude passwordHash\n    if (!user) {\n      return res.status(404).json({\n        message: 'User not found'\n      });\n    }\n    res.json(user);\n  } catch (err) {\n    console.error('Error fetching authenticated user:', err);\n    res.status(500).json({\n      message: 'Server error'\n    });\n  }\n});\nmodule.exports = router;","map":{"version":3,"names":["express","require","router","Router","bcrypt","jwt","User","verifyToken","JWT_SECRET","process","env","post","req","res","name","email","password","role","body","status","json","error","existingUser","findOne","saltRounds","hashedPassword","hash","user","passwordHash","save","token","sign","userId","_id","expiresIn","message","err","console","isValid","compare","get","findById","select","module","exports"],"sources":["C:/MERN/CampusOrbit – All-in-One Student Engagement System/frontend/src/hooks/useAuth.js"],"sourcesContent":["const express = require('express');\r\nconst router = express.Router();\r\nconst bcrypt = require('bcrypt');\r\nconst jwt = require('jsonwebtoken');\r\nconst User = require('../models/User');\r\nconst { verifyToken } = require('../middleware/auth'); // Import your JWT verify middleware\r\nconst JWT_SECRET = process.env.JWT_SECRET || \"your_secret_key_here\";\r\n// REGISTER route\r\nrouter.post('/register', async (req, res) => {\r\n  try {\r\n    const { name, email, password, role } = req.body;\r\n    if (!name || !email || !password) {\r\n      return res.status(400).json({ error: 'Name, email, and password are required' });\r\n    }\r\n    const existingUser = await User.findOne({ email });\r\n    if (existingUser) {\r\n      return res.status(400).json({ error: 'Email is already registered' });\r\n    }\r\n    const saltRounds = 10;\r\n    const hashedPassword = await bcrypt.hash(password, saltRounds);\r\n    const user = new User({\r\n      name,\r\n      email,\r\n      passwordHash: hashedPassword,\r\n      role: role || 'student',\r\n    });\r\n    await user.save();\r\n    const token = jwt.sign(\r\n      { userId: user._id, role: user.role },\r\n      JWT_SECRET,\r\n      { expiresIn: '1d' }\r\n    );\r\n    res.status(201).json({\r\n      message: 'User registered successfully',\r\n      token,\r\n    });\r\n  } catch (err) {\r\n    console.error('Register error:', err);\r\n    res.status(500).json({ error: 'Server error' });\r\n  }\r\n});\r\n// LOGIN route\r\nrouter.post('/login', async (req, res) => {\r\n  try {\r\n    const { email, password } = req.body;\r\n    if (!email || !password) {\r\n      return res.status(400).json({ error: 'Email and password are required' });\r\n    }\r\n    const user = await User.findOne({ email });\r\n    if (!user) {\r\n      return res.status(401).json({ error: 'Invalid email or password' });\r\n    }\r\n    const isValid = await bcrypt.compare(password, user.passwordHash);\r\n    if (!isValid) {\r\n      return res.status(401).json({ error: 'Invalid email or password' });\r\n    }\r\n    const token = jwt.sign(\r\n      { userId: user._id, role: user.role },\r\n      JWT_SECRET,\r\n      { expiresIn: '1d' }\r\n    );\r\n    res.json({\r\n      message: 'Login successful',\r\n      token,\r\n    });\r\n  } catch (err) {\r\n    console.error('Login error:', err);\r\n    res.status(500).json({ error: 'Server error' });\r\n  }\r\n});\r\n// GET current authenticated user info\r\nrouter.get('/me', verifyToken, async (req, res) => {\r\n  try {\r\n    const userId = req.user.userId; // obtained from verifyToken middleware\r\n    const user = await User.findById(userId).select('-passwordHash'); // exclude passwordHash\r\n    if (!user) {\r\n      return res.status(404).json({ message: 'User not found' });\r\n    }\r\n    res.json(user);\r\n  } catch (err) {\r\n    console.error('Error fetching authenticated user:', err);\r\n    res.status(500).json({ message: 'Server error' });\r\n  }\r\n});\r\nmodule.exports = router;"],"mappings":"AAAA,MAAMA,OAAO,GAAGC,OAAO,CAAC,SAAS,CAAC;AAClC,MAAMC,MAAM,GAAGF,OAAO,CAACG,MAAM,CAAC,CAAC;AAC/B,MAAMC,MAAM,GAAGH,OAAO,CAAC,QAAQ,CAAC;AAChC,MAAMI,GAAG,GAAGJ,OAAO,CAAC,cAAc,CAAC;AACnC,MAAMK,IAAI,GAAGL,OAAO,CAAC,gBAAgB,CAAC;AACtC,MAAM;EAAEM;AAAY,CAAC,GAAGN,OAAO,CAAC,oBAAoB,CAAC,CAAC,CAAC;AACvD,MAAMO,UAAU,GAAGC,OAAO,CAACC,GAAG,CAACF,UAAU,IAAI,sBAAsB;AACnE;AACAN,MAAM,CAACS,IAAI,CAAC,WAAW,EAAE,OAAOC,GAAG,EAAEC,GAAG,KAAK;EAC3C,IAAI;IACF,MAAM;MAAEC,IAAI;MAAEC,KAAK;MAAEC,QAAQ;MAAEC;IAAK,CAAC,GAAGL,GAAG,CAACM,IAAI;IAChD,IAAI,CAACJ,IAAI,IAAI,CAACC,KAAK,IAAI,CAACC,QAAQ,EAAE;MAChC,OAAOH,GAAG,CAACM,MAAM,CAAC,GAAG,CAAC,CAACC,IAAI,CAAC;QAAEC,KAAK,EAAE;MAAyC,CAAC,CAAC;IAClF;IACA,MAAMC,YAAY,GAAG,MAAMhB,IAAI,CAACiB,OAAO,CAAC;MAAER;IAAM,CAAC,CAAC;IAClD,IAAIO,YAAY,EAAE;MAChB,OAAOT,GAAG,CAACM,MAAM,CAAC,GAAG,CAAC,CAACC,IAAI,CAAC;QAAEC,KAAK,EAAE;MAA8B,CAAC,CAAC;IACvE;IACA,MAAMG,UAAU,GAAG,EAAE;IACrB,MAAMC,cAAc,GAAG,MAAMrB,MAAM,CAACsB,IAAI,CAACV,QAAQ,EAAEQ,UAAU,CAAC;IAC9D,MAAMG,IAAI,GAAG,IAAIrB,IAAI,CAAC;MACpBQ,IAAI;MACJC,KAAK;MACLa,YAAY,EAAEH,cAAc;MAC5BR,IAAI,EAAEA,IAAI,IAAI;IAChB,CAAC,CAAC;IACF,MAAMU,IAAI,CAACE,IAAI,CAAC,CAAC;IACjB,MAAMC,KAAK,GAAGzB,GAAG,CAAC0B,IAAI,CACpB;MAAEC,MAAM,EAAEL,IAAI,CAACM,GAAG;MAAEhB,IAAI,EAAEU,IAAI,CAACV;IAAK,CAAC,EACrCT,UAAU,EACV;MAAE0B,SAAS,EAAE;IAAK,CACpB,CAAC;IACDrB,GAAG,CAACM,MAAM,CAAC,GAAG,CAAC,CAACC,IAAI,CAAC;MACnBe,OAAO,EAAE,8BAA8B;MACvCL;IACF,CAAC,CAAC;EACJ,CAAC,CAAC,OAAOM,GAAG,EAAE;IACZC,OAAO,CAAChB,KAAK,CAAC,iBAAiB,EAAEe,GAAG,CAAC;IACrCvB,GAAG,CAACM,MAAM,CAAC,GAAG,CAAC,CAACC,IAAI,CAAC;MAAEC,KAAK,EAAE;IAAe,CAAC,CAAC;EACjD;AACF,CAAC,CAAC;AACF;AACAnB,MAAM,CAACS,IAAI,CAAC,QAAQ,EAAE,OAAOC,GAAG,EAAEC,GAAG,KAAK;EACxC,IAAI;IACF,MAAM;MAAEE,KAAK;MAAEC;IAAS,CAAC,GAAGJ,GAAG,CAACM,IAAI;IACpC,IAAI,CAACH,KAAK,IAAI,CAACC,QAAQ,EAAE;MACvB,OAAOH,GAAG,CAACM,MAAM,CAAC,GAAG,CAAC,CAACC,IAAI,CAAC;QAAEC,KAAK,EAAE;MAAkC,CAAC,CAAC;IAC3E;IACA,MAAMM,IAAI,GAAG,MAAMrB,IAAI,CAACiB,OAAO,CAAC;MAAER;IAAM,CAAC,CAAC;IAC1C,IAAI,CAACY,IAAI,EAAE;MACT,OAAOd,GAAG,CAACM,MAAM,CAAC,GAAG,CAAC,CAACC,IAAI,CAAC;QAAEC,KAAK,EAAE;MAA4B,CAAC,CAAC;IACrE;IACA,MAAMiB,OAAO,GAAG,MAAMlC,MAAM,CAACmC,OAAO,CAACvB,QAAQ,EAAEW,IAAI,CAACC,YAAY,CAAC;IACjE,IAAI,CAACU,OAAO,EAAE;MACZ,OAAOzB,GAAG,CAACM,MAAM,CAAC,GAAG,CAAC,CAACC,IAAI,CAAC;QAAEC,KAAK,EAAE;MAA4B,CAAC,CAAC;IACrE;IACA,MAAMS,KAAK,GAAGzB,GAAG,CAAC0B,IAAI,CACpB;MAAEC,MAAM,EAAEL,IAAI,CAACM,GAAG;MAAEhB,IAAI,EAAEU,IAAI,CAACV;IAAK,CAAC,EACrCT,UAAU,EACV;MAAE0B,SAAS,EAAE;IAAK,CACpB,CAAC;IACDrB,GAAG,CAACO,IAAI,CAAC;MACPe,OAAO,EAAE,kBAAkB;MAC3BL;IACF,CAAC,CAAC;EACJ,CAAC,CAAC,OAAOM,GAAG,EAAE;IACZC,OAAO,CAAChB,KAAK,CAAC,cAAc,EAAEe,GAAG,CAAC;IAClCvB,GAAG,CAACM,MAAM,CAAC,GAAG,CAAC,CAACC,IAAI,CAAC;MAAEC,KAAK,EAAE;IAAe,CAAC,CAAC;EACjD;AACF,CAAC,CAAC;AACF;AACAnB,MAAM,CAACsC,GAAG,CAAC,KAAK,EAAEjC,WAAW,EAAE,OAAOK,GAAG,EAAEC,GAAG,KAAK;EACjD,IAAI;IACF,MAAMmB,MAAM,GAAGpB,GAAG,CAACe,IAAI,CAACK,MAAM,CAAC,CAAC;IAChC,MAAML,IAAI,GAAG,MAAMrB,IAAI,CAACmC,QAAQ,CAACT,MAAM,CAAC,CAACU,MAAM,CAAC,eAAe,CAAC,CAAC,CAAC;IAClE,IAAI,CAACf,IAAI,EAAE;MACT,OAAOd,GAAG,CAACM,MAAM,CAAC,GAAG,CAAC,CAACC,IAAI,CAAC;QAAEe,OAAO,EAAE;MAAiB,CAAC,CAAC;IAC5D;IACAtB,GAAG,CAACO,IAAI,CAACO,IAAI,CAAC;EAChB,CAAC,CAAC,OAAOS,GAAG,EAAE;IACZC,OAAO,CAAChB,KAAK,CAAC,oCAAoC,EAAEe,GAAG,CAAC;IACxDvB,GAAG,CAACM,MAAM,CAAC,GAAG,CAAC,CAACC,IAAI,CAAC;MAAEe,OAAO,EAAE;IAAe,CAAC,CAAC;EACnD;AACF,CAAC,CAAC;AACFQ,MAAM,CAACC,OAAO,GAAG1C,MAAM","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}